#!/usr/bin/env python

"""
Limit order book 

Notes
-----
* Market orders are immediately executed at best buy and best ask values; if the
  book is empty (i.e., no limit orders have been placed yet), the market order
  is automatically canceled.
* All outstanding limit orders expire at the end of the day.
* Attempting to execute a buy/sell market order prior to the arrival of any
  sell/buy limit orders that can satisfy it (both in terms of quantity and price).
* When a limit order arrives that can satisfy an outstanding limit order, it is
  executed and the corresponding order is removed from the book.
* More information re LOBs can be found at 
  http://iopscience.iop.org/0295-5075/75/3/510/fulltext/
"""

import bintrees
import copy
import csv
import datetime
import logging
import numpy as np
import odict
import pandas
import sys
import time

col_names = \
  ['record_indicator',
   'segment',
   'order_number',
   'trans_date',
   'trans_time',
   'buy_sell_indicator',
   'activity_type',
   'symbol',
   'instrument',
   'expiry_date',
   'strike_price',
   'option_type',
   'volume_disclosed',
   'volume_original',
   'limit_price',
   'trigger_price',
   'mkt_flag',
   'on_stop_flag',
   'io_flag',
   'spread_comb_type',
   'algo_ind',
   'client_id_flag']

# Some aliases for bids and asks:
BID = BUY = 'B'
ASK = SELL = 'S'

class LimitOrderBook(object):
    """
    Limit order book.

    Parameters    
    ----------

    Notes
    -----
    Orders at each price level are stored in an ordered dict keyed by order
    number; new orders are implicitly appended whenever they are added to the dict.

    """
    
    def __init__(self, tick_size=0.05):
        self.logger = logging.getLogger('lob')

        # All limit prices are a multiple of the tick size:
        self.tick_size = tick_size

        # The order data in the book is stored in two dictionaries of ordered
        # dicts; the keys of each dictionary correspond to the price levels of
        # each ordered dict. The ordered dicts are used as
        # queues; adding a new entry with a key corresponding to the order
        # number is equivalent to pushing it into the queue, and the ordered
        # dict permits one to "pop" its first entry:
        self._book_data = {}
        self._book_data[BID] = {}
        self._book_data[ASK] = {}

        # Use Cython-based bintrees classes to keep track of the best bid and
        # ask without having to compute the maximum/minimum prices of the buy
        # and sell portions of the book:
        # XXX For some reason, using the Cython-based bintrees classes to store
        # the book data results in a segfault. Saving only the prices in one of
        # these classes appears to prevent this problem from occurring:
        self._book_prices = {}
        self._book_prices[BID] = bintrees.FastBinaryTree()
        self._book_prices[ASK] = bintrees.FastBinaryTree()
        
        # This dictionary maps price levels to dictionaries that contain several
        # running stats for each level
        self._price_level_stats = {}
        self._price_level_stats[BID] = {}
        self._price_level_stats[ASK] = {}
        self._init_price_level_stats = {
            'volume_original_total': 0,
            'volume_disclosed_total': 0
            }
        
        # This dictionary maps the IDs of orders that are in the book to their
        # price level:
        self._book_orders_to_price = {}
                
        # Generated events counter:
        self._event_counter = 1

        # Counter for original events, i.e., those that are not generated by the
        # LOB:
        self._original_event_counter = 1
        
        # Events are stored consecutively in this list:
        self._events = []

        # Events are written to this file:
        self._events_log_file = open('events.log', 'w')
        self._events_writer = csv.writer(self._events_log_file)
        
        # Accumulated data for daily stats is stored in this dictionary:        
        self._daily_stats = {}
        self._init_daily_stats = {
            'num_orders': 0,
            'num_trades': 0,
            'trade_volume_total': 0.0,
            'trade_price_mean': 0.0,
            'trade_price_std': 0.0,
            'mean_order_interarrival_time': 0.0
            }
        self._curr_daily_stats = copy.copy(self._init_daily_stats)
        self._last_order_time = 0.0
        
        # Daily trade volume is stored in this dictionary:
        self._trade_vol = {}
        self._curr_day = None
        self._curr_trade_vol = 0

        # Order interarrival times are stored in this dictionary:
        self._order_interarrival_time = {}
        self._curr_order_interarrival_time = None

    def __del__(self):
        try:
            self._events_log_file.close()
        except:
            pass
            
    def clear_book(self):
        """
        Clear all outstanding limit orders from the book

        Notes
        -----
        The trade counter is reset to 1, but all previously
        recorded trades are not erased.
        
        """

        self.logger.info('clearing outstanding limit orders')
        for d in self._book_data.keys():
            self._book_data[d].clear()
            self._book_prices[d].clear()
            self._price_level_stats[d].clear()
        self._book_orders_to_price.clear()
        
    def process(self, df, show_output=True, log_events=True):
        """
        Process order data

        Parameters
        ----------
        df : pandas.DataFrame
            Each row of this DataFrame instance contains a single order.
        show_output : bool
            Display last event and book state after recording every event.
            
        """

        self.show_output = show_output
        self.log_events = log_events
        
        expiry_date = ''
        day = None
        for row in df.iterrows():
            order = row[1].to_dict()
            self.logger.info('processing order: %i' % order['order_number'])

            # Reset the limit order book and trade volume variables when a new
            # day of orders begins:
            trans_date = datetime.datetime.strptime(order['trans_date'], '%m/%d/%Y')
            if day is None:
                day = trans_date.day
                self.logger.info('setting day: %s' % day)

                # Reset variables used for accumulating daily stats:
                self._curr_day = order['trans_date']
                self._last_order_time = \
                  datetime.datetime.strptime(order['trans_date']+' '+\
                                             order['trans_time'],
                                             '%m/%d/%Y %H:%M:%S.%f')
                self._curr_daily_stats = \
                    copy.copy(self._init_daily_stats)
            elif day != trans_date.day:
                self.logger.info('new day - book reset')
                self.clear_book()

                # Save daily stats before resetting variables used for
                # accumulating daily stats:
                self._curr_day = order['trans_date']
                self._last_order_time = \
                  datetime.datetime.strptime(order['trans_date']+' '+\
                                             order['trans_time'],
                                             '%m/%d/%Y %H:%M:%S.%f')                
                self._daily_stats[self._curr_day] = \
                    copy.copy(self.curr_daily_stats)
                self._curr_daily_stats = \
                    copy.copy(self._init_daily_stats)

            # Restrict all orders processed to a single expiry date because
            # futures orders with different expiry dates are effectively
            # distinct securities insofar as the LOB is concerned:
            if not expiry_date:
                self.logger.info('setting expiry date: %s' % expiry_date)
                expiry_date = order['expiry_date']                
            else:
                if expiry_date != order['expiry_date']:
                    self.logger.info('skipping order %s with expiry date %s' % \
                                     (order['order_number'], order['expiry_date']))
                    continue
                    
            if order['activity_type'] == 1:
                self.add(order, 'Y')
            elif order['activity_type'] == 3:
                self.cancel(order)
            elif order['activity_type'] == 4:
                # XXX It seems that a few market orders are listed as modify orders;
                # temporarily treat them as add operations XXX                  
                if order['mkt_flag'] == 'Y':
                    self.add(order, 'Y')
                else:    
                    self.modify(order)
            else:
                raise ValueError('unrecognized activity type %i' % \
                                 order['activity_type'])
                
        # Save current stats when no more orders are available:
        self._daily_stats[self._curr_day] = \
            copy.copy(self._curr_daily_stats)

    def create_level(self, indicator, price):
        """
        Create a new empty price level queue.

        Parameters
        ----------
        indicator : str
            Indicate whether to create a new buy ('B') or sell ('S') price
            level.
        price : float
            Price associated with new level.

        Returns
        -------
        od : odict
            New price level queue.
        
        """

        od = odict.odict()
        self._book_data[indicator][price] = od
        self._book_prices[indicator][price] = True        
        self._price_level_stats[indicator][price] = \
            copy.copy(self._init_price_level_stats)
        self.logger.info('created new price level: %s, %f' % (indicator, price))
        return od
    
    def delete_level(self, indicator, price):
        """
        Delete an existing price level.

        Parameters
        ----------
        indicator : str
            Indicate whether to delete a buy ('B') or sell ('S') price level.
        price : float
            Price associated with level.

        """
        
        self._book_data[indicator].pop(price)
        self._book_prices[indicator].pop(price)
        self._price_level_stats[indicator].pop(price)
        self.logger.info('deleted price level: %s, %f' % (indicator, price))

    def add_order(self, order):
        """
        Add an order to the book.

        Parameters
        ----------
        order : dict
            Order data.
            
        """

        order_number = order['order_number']
        indicator = order['buy_sell_indicator']
        price = order['limit_price']
        od = self.price_level(indicator, price)

        # Create a new price level queue if none exists for the order's
        # limit price:
        if od is None:
            self.logger.info('no matching price level found')
            od = self.create_level(indicator, price)
        
        od[order_number] = order
        self._book_orders_to_price[order_number] = od
        
        # Update price level stats:
        self._price_level_stats[indicator][price]['volume_original_total'] += \
            order['volume_original']
        self._price_level_stats[indicator][price]['volume_disclosed_total'] += \
            order['volume_disclosed']
            
        self.logger.info('added order: %s, %s, %s' % \
                            (order_number, indicator, price))    
            
    def delete_order(self, order):
        """
        Delete an order from the book.

        Parameters
        ----------
        order : dict
            Order data.

        Notes
        -----
        If the price level queue containing the specified order is empty after
        the order is deleted, it is removed from the limit order book.
        
        """

        order_number = order['order_number']
        try:
            od = self._book_orders_to_price.pop(order_number)
        except:
            self.logger.info('order not found: %s' % order_number)
        else:
            order = od.pop(order_number)
            indicator = order['buy_sell_indicator']
            price = order['limit_price']

            # Update price level stats:
            self._price_level_stats[indicator][price]['volume_original_total'] -= \
                order['volume_original']
            self._price_level_stats[indicator][price]['volume_disclosed_total'] -= \
                order['volume_disclosed']

            self.logger.info('deleted order: %s, %s, %s' % \
                             (order_number, indicator, price))    
            
            # If the price level queue contains no other orders, remove it:
            if not od:
                self.delete_level(indicator, price)
            
    def best_bid_price(self):
        """
        Return the best bid price defined in the book.

        Returns
        -------
        order : dict
            Limit order with best (highest) bid price.

        Notes
        -----
        Assumes that there are no empty price levels in the book.
        
        """

        try:
            best_price = self._book_prices[BID].max_key()
        except:
            return None
        else:
            return best_price
        
    def best_bid_data(self):
        """
        Return data associated with the best bid

        Returns
        -------
        best_bid_price : float
            Bid price.
        volume_original_total : int
            Total original volume.
        volume_disclosed_total : int
            Total disclosed volume.
       
        """
        
        best_bid_price = self.best_bid_price()
        if best_bid_price is not None:
            volume_original_total = \
                self._price_level_stats[BID][best_bid_price]['volume_original_total']
            volume_disclosed_total = \
                self._price_level_stats[BID][best_bid_price]['volume_disclosed_total']
        else:
            volume_original_total = volume_disclosed_total = 0
        return best_bid_price, volume_original_total, volume_disclosed_total
    
    def best_ask_price(self):
        """
        Return the best ask price defined in the book.

        Returns
        -------
        order : dict
            Limit order with best (lowest) ask price.

        Notes
        -----
        Assumes that there are no empty price levels in the book.
        
        """

        try:
            best_price = self._book_prices[ASK].min_key()
        except:
            return None
        else:
            return best_price

    def best_ask_data(self):
        """
        Return data associated with the best ask.

        Returns
        -------
        ask_price : float
            Ask price.
        volume_original_total : int
            Total original volume.
        volume_disclosed_total : int
            Total disclosed volume.
       
        """
        
        best_ask_price = self.best_ask_price()
        if best_ask_price is not None:
            volume_original_total = \
                self._price_level_stats[ASK][best_ask_price]['volume_original_total']
            volume_disclosed_total = \
                self._price_level_stats[ASK][best_ask_price]['volume_disclosed_total']
        else:
            volume_original_total = volume_disclosed_total = 0
        return best_ask_price, volume_original_total, volume_disclosed_total
        
    def price_level(self, indicator, price):
        """
        Find a specified price level in the limit order book.
        
        Parameters
        ----------
        indicator : str
            Indicate whether to find a buy ('B') or sell ('S') price level.
        price : float
            Price associated with level.
        
        Returns
        -------
        od : odict.odict
            Ordered dict with matching price level.

        """

        # Validate buy/sell indicator:
        try:
            book = self._book_data[indicator]
        except KeyError:
            raise ValueError('invalid buy/sell indicator')

        # Look for price level queue:
        try:
            od = book[price]
        except KeyError:
            #self.logger.info('price level not found: %s, %f' % (indicator, price))
            return None
        else:
            #self.logger.info('price level found: %s, %f' % (indicator, price))
            return od

    def record_event(self, **kwargs):
        """
        This routine saves the specified event information.
        """

        # Events to record: cancel bid, cancel ask, add bid, add ask,
        # Each entry contains:
        # time, date, price, order number,
        # whether an order is original (Y) or generated by the LOB (N),
        # action (add, modify, cancel), indicator (B or S),
        # market order status (Y or N),
        # io status (Y or N),
        # original order quantity, disclosed
        # quantity, best bid, best bid original volume, best bid disclosed volume,
        # best ask, best ask original volume, best ask disclosed volume,
        # trade data (dict)
        # If a trade has not occurred, the trade data dict is empty;
        # if a trade has occurred, the trade data dict contains:
        # trade price, trade quantity, buy order number, sell order number

        self._events.append(kwargs)
        self._event_counter += 1

        # Accumulate stats for arriving original orders (i.e., NOT orders
        # that are generated in response to modify requests):
        if kwargs['is_original'] == 'Y':
            self._original_event_counter += 1
            self._curr_daily_stats['num_orders'] += 1

            # Compute time since last order arrival:
            date_time = datetime.datetime.strptime(kwargs['date']+' '+\
                                                   kwargs['time'],
                                                   '%m/%d/%Y %H:%M:%S.%f')
            curr_interarrival_time = \
                (date_time-self._last_order_time).total_seconds()
            if self._curr_daily_stats['num_orders'] == 1:
                self._curr_daily_stats['mean_order_interarrival_time'] = \
                    curr_interarrival_time
            else:
                N = float(self._curr_daily_stats['num_orders'])
                N_prev = N-1
                self._curr_daily_stats['mean_order_interarrival_time'] = \
                    self._curr_daily_stats['mean_order_interarrival_time']*(N_prev/N)+\
                    curr_interarrival_time/N
                    
        # Accumulate stats for generated trades:
        if kwargs['trade']:

            # Number of trades:
            self._curr_daily_stats['num_trades'] += 1

            # Total trade volume:
            self._curr_daily_stats['trade_volume_total'] += \
                kwargs['trade']['trade_quantity']

            # Average trade price:
            if self._curr_daily_stats['num_trades'] == 1:                
                self._curr_daily_stats['trade_price_mean'] = \
                    kwargs['trade']['trade_price']
            else:
                N = float(self._curr_daily_stats['num_trades'])
                N_prev = N-1
                self._curr_daily_stats['trade_price_mean'] = \
                    (self._curr_daily_stats['trade_price_mean']*N_prev+\
                    kwargs['trade']['trade_price'])/N
                self._curr_daily_stats['trade_price_std'] = \
                  np.sqrt((self._curr_daily_stats['trade_price_std']**2*N_prev+\
                          (kwargs['trade']['trade_price']-self._curr_daily_stats['trade_price_mean'])**2)/N)

        if self.show_output:
            print '----------------------------------------'

            # Print last event:
            if kwargs['is_original'] == 'Y':
                print self._original_event_counter-1, self.event_to_row(self._events[-1])
            else:
                print 'X', self.event_to_row(self._events[-1])
            
            # Print queue states:
            print 'sell queue:'
            self.print_book(SELL)
            print 'buy queue:'
            self.print_book(BUY)

        if self.log_events:
            event = self._events[-1]
            row = self.event_to_row(event)
            self._events_writer.writerow(row)
            
    def add(self, new_order, is_original):
        """
        Add the specified order to the LOB.
        
        Parameters
        ----------
        new_order : dict
            Order to add.
        is_original : char
            'Y' if the order is original (i.e., not generated by the LOB in
            response to certain modification requests), 'N' otherwise.
            
        Notes
        -----        
        New orders are implicitly appended onto the end of each ordered dict.
        One can obtain the oldest order by popping the first entry in the dict.
        
        """

        best_bid_price, best_bid_volume_original, best_bid_volume_disclosed = \
          self.best_bid_data()
        best_ask_price, best_ask_volume_original, best_ask_volume_disclosed = \
          self.best_ask_data()
        event = \
          dict(time=new_order['trans_time'],
               date=new_order['trans_date'],
               price=new_order['limit_price'],
               order_number=new_order['order_number'],
               is_original=is_original,
               action='add',
               indicator=new_order['buy_sell_indicator'],
               mkt_flag=new_order['mkt_flag'],
               io_flag=new_order['io_flag'],
               volume_original=new_order['volume_original'],
               volume_disclosed=new_order['volume_disclosed'],
               best_bid_price=best_bid_price,
               best_bid_volume_original=best_bid_volume_original,
               best_ask_price=best_ask_price,
               best_ask_volume_original=best_ask_volume_original,    
               trade={})
        
        new_indicator = new_order['buy_sell_indicator']
        volume_original = new_order['volume_original']
        volume_disclosed = new_order['volume_disclosed']

        self.logger.info('attempting add of order: %s, %s, %s, %f, %d, %d' % \
                         (new_order['order_number'], new_indicator, new_order['mkt_flag'],
                         new_order['limit_price'], volume_original,
                         volume_disclosed))
        
        # If the buy/sell order is a market order, check whether there is a
        # corresponding limit order in the book at the best ask/bid price:
        if new_order['mkt_flag'] == 'Y':
            while volume_original > 0:
                if new_indicator == BUY:
                    buy_order = new_order
                    best_price = self.best_ask_price()

                    # Sell/buy market orders cannot be processed until there is
                    # at least one bid/ask limit order in the book:
                    if best_price is None:
                        self.logger.info('no sell limit orders in book yet')
                    od = self.price_level(ASK, best_price) 
                elif new_indicator == SELL:
                    sell_order = new_order
                    best_price = self.best_bid_price()

                    # Sell/buy market orders cannot be processed until there is
                    # at least one bid/ask limit order in the book:
                    if best_price is None:
                        self.logger.info('no buy limit orders in book yet') 
                    od = self.price_level(BID, best_price)
                else:
                    RuntimeError('invalid buy/sell indicator')

                # If there is still residual volume but the best price is no
                # longer compatible with that of the arriving order, stop
                # trying to match orders:
                if new_indicator == BUY and best_price > new_order['limit_price']:
                    self.logger.info('best ask exceeds specified buy price')
                    break
                if new_indicator == SELL and best_price < new_order['limit_price']:
                    self.logger.info('best bid is below specified sell price')
                    break

                # Orders in the book that have explicitly disclosed (i.e.,
                # non-zero) volumes must be processed before others; hence, we
                # need to reorder the orders in the identified price level to
                # list all orders with disclosed volumes before the others:
                order_number_list = []
                for order_number in od.keys():
                    if od[order_number]['volume_disclosed'] > 0:
                        order_number_list.append(order_number)
                for order_number in od.keys():
                    if od[order_number]['volume_disclosed'] == 0:
                        order_number_list.append(order_number)
                        
                # Move through the limit orders in the price level queue from oldest
                # to newest:
                for order_number in order_number_list:
                    curr_order = od[order_number]
                    if curr_order['buy_sell_indicator'] == BUY:
                        buy_order = curr_order
                    elif curr_order['buy_sell_indicator'] == SELL:
                        sell_order = curr_order
                    else:
                        RuntimeError('invalid buy/sell indicator')

                    # If a bid/ask limit order in the book has the same volume as
                    # that requested in the sell/buy market order, record a
                    # transaction and remove the limit order from the queue:
                    if curr_order['volume_original'] == volume_original:
                        self.logger.info('current limit order original volume '
                                         'vs. arriving market order original volume: '
                                         '%s = %s' % \
                                         (curr_order['volume_original'],
                                          volume_original))
                        trade = dict(trade_price=best_price,
                                     trade_quantity=volume_original,
                                     buy_order_number=buy_order['order_number'],
                                     sell_order_number=sell_order['order_number'])
                        event['trade'] = trade
                        self.record_event(**event)
                        self.delete_order(curr_order) 
                        volume_original = 0.0                 
                        break

                    # If a bid/ask limit order in the book has a greater volume
                    # than that requested in the sell/buy market order, record a
                    # transaction and decrement its volume accordingly:
                    elif curr_order['volume_original'] > volume_original:
                        self.logger.info('current limit order original volume '
                                         'vs. arriving market order original volume: '
                                         '%s > %s' % \
                                         (curr_order['volume_original'],
                                          volume_original))   
                        trade = dict(trade_price=best_price,
                                     trade_quantity=volume_original,
                                     buy_order_number=buy_order['order_number'],
                                     sell_order_number=sell_order['order_number'])
                        event['trade'] = trade
                        self.record_event(**event)
                        if new_order['io_flag'] == 'N':
                            self.logger.info('Non-IOC order - residual volume preserved')
                            curr_order['volume_original'] -= volume_original
                            self._price_level_stats[curr_order['buy_sell_indicator']][curr_order['limit_price']]['volume_original_total'] \
                                -= volume_original
                        else:
                            self.logger.info('IOC order - residual volume discarded')
                        volume_original = 0.0
                        break

                    # If the bid/ask limit order in the book has a volume that is
                    # below the requested sell/buy market order volume, continue
                    # removing orders from the queue until the entire requested
                    # volume has been satisfied:
                    elif curr_order['volume_original'] < volume_original:
                        self.logger.info('current limit order original volume '
                                         'vs. arriving market order original volume: '
                                         '%s < %s' % \
                                         (curr_order['volume_original'],
                                          volume_original))                  
                        trade = dict(trade_price=best_price,
                                     trade_quantity=curr_order['volume_original'],
                                     buy_order_number=buy_order['order_number'],
                                     sell_order_number=sell_order['order_number'])
                        event['trade'] = trade
                        self.record_event(**event)
                        volume_original -= curr_order['volume_original']
                        self.delete_order(curr_order)
                    else:

                        # This should never be reached:
                        pass

        elif new_order['mkt_flag'] == 'N':

            # Check whether the limit order is marketable:
            price = new_order['limit_price']
            marketable = True
            if new_indicator == BUY and self.best_ask_price() is not None and price >= self.best_ask_price():
                self.logger.info('buy order is marketable')
                best_price = self.best_ask_price();
            elif new_indicator == SELL and self.best_bid_price() is not None and price <= self.best_bid_price():
                self.logger.info('sell order is marketable')
                best_price = self.best_bid_price();
            else:
                marketable = False

            # If the limit order is not marketable, add it to the appropriate
            # price level queue in the limit order book:
            if not marketable:
                self.logger.info('order is not marketable')
                self.record_event(**event)
                self.add_order(new_order)
                
            # Try to match marketable orders with orders that are already in the
            # book:
            else:

                # If the requested volume in the order isn't completely
                # satisfied at the best price, recompute the best price and
                # try to satisfy the remainder:
                while volume_original > 0.0:
                    if new_indicator == BUY:
                        buy_order = new_order                    
                        best_price = self.best_ask_price()
                        od = self.price_level(ASK, best_price) 
                    elif new_indicator == SELL:
                        sell_order = new_order
                        best_price = self.best_bid_price()                
                        od = self.price_level(BID, best_price)
                    else:
                        RuntimeError('invalid buy/sell indicator')

                    # If there is still residual volume but the best price is no
                    # longer compatible with that of the arriving order, stop
                    # trying to match orders and save the residue as a new limit
                    # order:
                    if new_indicator == BUY and best_price > new_order['limit_price']:
                        self.logger.info('best ask exceeds specified buy price')
                        if new_order['io_flag'] == 'N':
                            new_order['volume_original'] = volume_original
                            self.add(new_order, 'N')
                        break
                    if new_indicator == SELL and best_price < new_order['limit_price']:
                        self.logger.info('best bid is below specified sell price')
                        if new_order['io_flag'] == 'N':
                            new_order['volume_original'] = volume_original
                            self.add(new_order, 'N')
                        break

                    # Orders in the book that have explicitly disclosed (i.e.,
                    # non-zero) volumes must be processed before others; hence, we
                    # need to reorder the orders in the identified price level to
                    # list all orders with disclosed volumes before the others:
                    order_number_list = []
                    for order_number in od.keys():
                        if od[order_number]['volume_disclosed'] > 0:
                            order_number_list.append(order_number)
                    for order_number in od.keys():
                        if od[order_number]['volume_disclosed'] == 0:
                            order_number_list.append(order_number)
                    
                    # Move through the limit orders in the price level queue from
                    # oldest to newest:
                    for order_number in order_number_list: 
                        curr_order = od[order_number]
                        if new_indicator == BUY:
                            sell_order = curr_order
                        elif new_indicator == SELL:
                            buy_order = curr_order
                        else:
                            RuntimeError('invalid buy/sell indicator')

                        # If a bid/ask limit order in the book has the same volume
                        # as that requested in the sell/buy limit order, record a
                        # transaction and remove the limit order from the queue:
                        if curr_order['volume_original'] == volume_original:
                            self.logger.info('current limit order original volume '
                                             'vs. arriving limit order original volume: '
                                             '%s = %s' % \
                                             (curr_order['volume_original'],
                                              volume_original))       
                            trade = dict(trade_price=best_price,
                                         trade_quantity=volume_original,
                                         buy_order_number=buy_order['order_number'],
                                         sell_order_number=sell_order['order_number'])
                            event['trade'] = trade
                            self.record_event(**event)
                            self.delete_order(curr_order)
                            volume_original = 0.0
                            break
                        
                        # If a bid/ask limit order in the book has a greater volume
                        # than that requested in the sell/buy limit order, record a
                        # transaction and decrement its volume accordingly:
                        elif curr_order['volume_original'] > volume_original:
                            self.logger.info('current limit order original volume '
                                             'vs. arriving limit order original volume: '
                                             '%s > %s' % \
                                             (curr_order['volume_original'],
                                              volume_original))    
                            trade = dict(trade_price=best_price,
                                         trade_quantity=volume_original,
                                         buy_order_number=buy_order['order_number'],
                                         sell_order_number=sell_order['order_number'])
                            event['trade'] = trade
                            self.record_event(**event)
                            if new_order['io_flag'] == 'N':
                                self.logger.info('Non-IOC order - residual volume preserved')  
                                curr_order['volume_original'] -= volume_original
                                self._price_level_stats[curr_order['buy_sell_indicator']][curr_order['limit_price']]['volume_original_total'] \
                                  -= volume_original
    
                            else:
                                self.logger.info('IOC order - residual volume discarded')
                            volume_original = 0.0
                            break

                        # If the bid/ask limit order in the book has a volume that is
                        # below the requested sell/buy market order volume, continue
                        # removing orders from the queue until the entire requested
                        # volume has been satisfied:
                        elif curr_order['volume_original'] < volume_original:
                            self.logger.info('current limit order original volume '
                                             'vs. arriving limit order original volume: '
                                             '%s < %s' % \
                                             (curr_order['volume_original'],
                                              volume_original))     
                            trade = dict(trade_price=best_price,
                                         trade_quantity=curr_order['volume_original'],
                                         buy_order_number=buy_order['order_number'],
                                         sell_order_number=sell_order['order_number'])
                            event['trade'] = trade
                            self.record_event(**event)                            
                            volume_original -= curr_order['volume_original']
                            self.delete_order(curr_order) 
                        else:

                            # This should never be reached:
                            pass                                            
        else:
            raise RuntimeError('invalid market order flag')
        
    def modify(self, new_order):
        """
        Modify the order with matching order number in the LOB.
        """

        best_bid_price, best_bid_volume_original, best_bid_volume_disclosed = \
          self.best_bid_data()
        best_ask_price, best_ask_volume_original, best_ask_volume_disclosed = \
          self.best_ask_data()
        event = \
          dict(time=new_order['trans_time'],
               date=new_order['trans_date'],
               price=new_order['limit_price'],
               order_number=new_order['order_number'],
               is_original='Y',
               action='modify',
               indicator=new_order['buy_sell_indicator'],
               mkt_flag=new_order['mkt_flag'],
               io_flag=new_order['io_flag'],
               volume_original=new_order['volume_original'],
               volume_disclosed=new_order['volume_disclosed'],
               best_bid_price=best_bid_price,
               best_bid_volume_original=best_bid_volume_original,
               best_ask_price=best_ask_price,
               best_ask_volume_original=best_ask_volume_original,    
               trade={})

        self.logger.info('attempting modify of order: %s, %s' % \
                         (new_order['order_number'],
                         new_order['buy_sell_indicator']))
        
        # This exception should never be thrown:
        if new_order['mkt_flag'] == 'Y':
            raise ValueError('cannot modify market order')

        # A modify order contains the number of the existing order to modify and
        # a new limit price or quantity. We use the self._book_orders_to_price
        # dict to look up the existing order:
        book = self._book_data[new_order['buy_sell_indicator']]
        try:
            od = self._book_orders_to_price[new_order['order_number']]
        except:
            self.logger.info('order number %s not found' % new_order['order_number'])
        else:
            old_order = od[new_order['order_number']]
            
            # If the modify changes the price of an order, remove it and
            # then add the modified order to the appropriate price level queue:
            if new_order['limit_price'] != old_order['limit_price']:
                self.logger.info('modified order %i price from %f to %f: ' % \
                                 (new_order['order_number'],
                                  old_order['limit_price'],
                                  new_order['limit_price']))
                self.delete_order(old_order)                                   
                self.add(new_order, 'N')

            # If the modify reduces the original or disclosed volume of an
            # order, update it without altering where it is in the price level queue:
            elif new_order['volume_original'] < old_order['volume_original'] or \
                new_order['volume_disclosed'] < old_order['volume_disclosed']:
                self.logger.info('modified order %i (original, disclosed) volume '                    
                                 'from (%i, %i) to (%i, %i)' % \
                                 (new_order['order_number'],
                                  old_order['volume_original'], old_order['volume_disclosed'],
                                  new_order['volume_original'], new_order['volume_disclosed']))
                od[new_order['order_number']] = new_order

                # Update price level stats:
                self._price_level_stats[new_order['buy_sell_indicator']][new_order['limit_price']]['volume_original_total'] \
                    += -old_order['volume_original']+new_order['volume_original']
                self._price_level_stats[new_order['buy_sell_indicator']][new_order['limit_price']]['volume_disclosed_total'] \
                    += -old_order['volume_disclosed']+new_order['volume_disclosed']                
                
            # If the modify increases the original or disclosed volume of an
            # order, add a order containing the difference in volume between
            # the original and new orders:
            elif new_order['volume_original'] > old_order['volume_original'] or \
                new_order['volume_disclosed'] > old_order['volume_disclosed']:
                self.logger.info('modified order %i (original, disclosed) volume '
                                 'from (%i, %i) to (%i, %i)' % \
                                 (new_order['order_number'],
                                  old_order['volume_original'], old_order['volume_disclosed'],
                                  new_order['volume_original'], new_order['volume_disclosed']))
                new_order_modified = new_order.copy()
                new_order_modified['volume_original'] -= old_order['volume_original']
                new_order_modified['volume_disclosed'] -= old_order['volume_disclosed']
                self.add(new_order_modified, 'N')

                # Update price level stats:
                self._price_level_stats[new_order['buy_sell_indicator']][new_order['limit_price']]['volume_original_total'] \
                    += -old_order['volume_original']+new_order['volume_original']
                self._price_level_stats[new_order['buy_sell_indicator']][new_order['limit_price']]['volume_disclosed_total'] \
                    += -old_order['volume_disclosed']+new_order['volume_disclosed']                

            else:
                self.logger.info('undefined modify scenario')
                            
        self.record_event(**event)
        
    def cancel(self, order):
        """
        Remove the order with matching order number from the LOB.

        Parameters
        ----------
        order : dict
            Order to cancel.

        """
                
        best_bid_price, best_bid_volume_original, best_bid_volume_disclosed = \
          self.best_bid_data()
        best_ask_price, best_ask_volume_original, best_ask_volume_disclosed = \
          self.best_ask_data()
        event = \
          dict(time=order['trans_time'],
               date=order['trans_date'],
               price=order['limit_price'],
               order_number=order['order_number'],
               is_original='Y',
               action='cancel',
               indicator=order['buy_sell_indicator'],
               mkt_flag=order['mkt_flag'],
               io_flag=order['io_flag'],
               volume_original=order['volume_original'],
               volume_disclosed=order['volume_disclosed'],
               best_bid_price=best_bid_price,
               best_bid_volume_original=best_bid_volume_original,
               best_ask_price=best_ask_price,
               best_ask_volume_original=best_ask_volume_original,    
               trade={})

        self.logger.info('attempting cancel of order %s' % order['order_number'])

        # Filter out cancellation orders that are listed as market orders:
        if order['mkt_flag'] == 'Y':
            self.logger.info('cannot cancel market order %s' % order['order_number'])
        else:
            self.delete_order(order)
        self.record_event(**event)
                                                    
    def print_book(self, indicator):
        """
        Print parts of the specified book dictionary in a neat manner.
        """

        book = self._book_data[indicator]
        prices = self._book_prices[indicator]
        for price in prices.keys(True):
            print '%06.2f: ' % price,            
            for order_number in book[price]:
                order = book[price][order_number]
                print '(%s,%s)' % (order['volume_original'], order['volume_disclosed']),
            print ''

    def event_to_row(self, event):
        """
        Convert a dictionary containing event data into a row for output to CSV.
        """
        
        row = [event['time'],
               event['date'],
               event['price'],
               event['order_number'],
               event['is_original'],
               event['action'],
               event['indicator'],
               event['mkt_flag'],
               event['volume_original'],
               event['volume_disclosed'],
               event['best_bid_price'],
               event['best_bid_volume_original'],
               event['best_ask_price'],
               event['best_ask_volume_original']]
        trade = event['trade']
        if trade:
            row += ['trade',
                    trade['trade_price'],
                    trade['trade_quantity'],
                    trade['buy_order_number'],
                    trade['sell_order_number']]
        return row
    
    def print_events(self, file_name=None):
        if file_name is None:
            w = csv.writer(sys.stdout)
        else:
            f = open(file_name, 'wb')
            w = csv.writer(f)
        for entry in self._events.iteritems():
            n = entry[0]
            event = entry[1]
            row = self.event_to_row(event)
            w.writerow(row)
        if file_name is not None:
            f.close()

    def print_stats(self):
        print '----------------------------------------'
        print 'Number of orders:             ', self._curr_daily_stats['num_orders']
        print 'Number of trades:             ', self._curr_daily_stats['num_trades']
        print 'Total trade volume:           ', self._curr_daily_stats['trade_volume_total']
        print 'Mean trade price:             ', self._curr_daily_stats['trade_price_mean']
        print 'Trade price STD:              ', self._curr_daily_stats['trade_price_std']
        print 'Mean order interarrival time: ', self._curr_daily_stats['mean_order_interarrival_time']
        
if __name__ == '__main__':
    start = time.time()
    
    format = '%(asctime)s %(name)s %(levelname)s [%(funcName)s] %(message)s'
    logging.basicConfig(level=logging.DEBUG, format=format)

    # Remove root log handlers:
    for h in logging.root.handlers:
        logging.root.removeHandler(h)
                         
    lob = LimitOrderBook()
    fh = logging.FileHandler('lob.log', 'w')
    fh.setFormatter(logging.Formatter(format))
    lob.logger.addHandler(fh)

    file_name = 'AXISBANK-orders.csv'
    tp = pandas.read_csv(file_name,
                         names=col_names,
                         iterator=True)
    # for i in xrange(50):
    #     data = tp.get_chunk(200)
    #     lob.process(data)
    while True:
        data = tp.get_chunk(100)
        if data.irow(0)['trans_time'] > '9:25:00.000000':
            break
        lob.process(data)

    # while True:
    #     try:
    #         data = tp.get_chunk(200)
    #     except StopIteration:
    #         break
    #     else:
    #         lob.process(data)
            
    lob.print_stats()
    print 'Processing time:              ', (time.time()-start)
